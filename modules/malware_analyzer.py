#!/usr/bin/env python3
"""
Malware Analysis Basics Module
Basic static analysis for suspicious files
"""

import subprocess
import os
import re
import hashlib
import struct
from typing import Dict, List, Optional
from pathlib import Path


class MalwareAnalyzer:
    """Basic malware analysis for CTF challenges"""
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.results = {
            'file_info': {},
            'hashes': {},
            'strings': [],
            'imports': [],
            'exports': [],
            'sections': [],
            'suspicious_strings': [],
            'suspicious_apis': [],
            'packed': False,
            'packer_detected': None,
            'yara_matches': [],
            'flags_found': [],
            'iocs': []  # Indicators of Compromise
        }
        
        self.flag_patterns = [
            r'flag\{[^}]+\}',
            r'FLAG\{[^}]+\}',
            r'ctf\{[^}]+\}',
            r'CTF\{[^}]+\}',
            r'picoCTF\{[^}]+\}',
            r'HTB\{[^}]+\}',
            r'THM\{[^}]+\}'
        ]
        
        # Suspicious API calls
        self.suspicious_apis = {
            'process': ['CreateProcess', 'OpenProcess', 'TerminateProcess', 
                       'WriteProcessMemory', 'ReadProcessMemory', 'VirtualAllocEx',
                       'CreateRemoteThread', 'NtCreateThreadEx'],
            'file': ['CreateFile', 'WriteFile', 'DeleteFile', 'MoveFile',
                    'CopyFile', 'SetFileAttributes'],
            'registry': ['RegCreateKey', 'RegSetValue', 'RegOpenKey', 
                        'RegDeleteKey', 'RegDeleteValue'],
            'network': ['socket', 'connect', 'send', 'recv', 'WSAStartup',
                       'InternetOpen', 'InternetConnect', 'HttpOpenRequest',
                       'URLDownloadToFile', 'WinHttpOpen'],
            'crypto': ['CryptEncrypt', 'CryptDecrypt', 'CryptCreateHash',
                      'CryptAcquireContext', 'CryptGenKey'],
            'injection': ['VirtualAlloc', 'VirtualProtect', 'LoadLibrary',
                         'GetProcAddress', 'NtUnmapViewOfSection'],
            'anti_debug': ['IsDebuggerPresent', 'CheckRemoteDebuggerPresent',
                          'NtQueryInformationProcess', 'OutputDebugString'],
            'anti_vm': ['GetSystemInfo', 'GetVolumeInformation', 'GetComputerName',
                       'GetUserName', 'GetSystemDirectory'],
        }
        
        # Known packer signatures (simplified)
        self.packer_signatures = {
            'UPX': [b'UPX0', b'UPX1', b'UPX!'],
            'ASPack': [b'.aspack', b'ASPack'],
            'PECompact': [b'PEC2', b'pec1'],
            'Themida': [b'.themida'],
            'VMProtect': [b'.vmp0', b'.vmp1'],
            'Enigma': [b'.enigma'],
        }
    
    def _search_flags(self, text: str):
        """Search for flags"""
        for pattern in self.flag_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            for match in matches:
                if match not in self.results['flags_found']:
                    self.results['flags_found'].append(match)
                    print(f"[FLAG] Found: {match}")
    
    def calculate_hashes(self, filepath: str) -> Dict[str, str]:
        """Calculate file hashes"""
        print("[*] Calculating file hashes...")
        
        hashes = {}
        
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            
            hashes['md5'] = hashlib.md5(data).hexdigest()
            hashes['sha1'] = hashlib.sha1(data).hexdigest()
            hashes['sha256'] = hashlib.sha256(data).hexdigest()
            
            print(f"[+] MD5:    {hashes['md5']}")
            print(f"[+] SHA1:   {hashes['sha1']}")
            print(f"[+] SHA256: {hashes['sha256']}")
            
            self.results['hashes'] = hashes
            
        except Exception as e:
            print(f"[!] Hash calculation error: {e}")
        
        return hashes
    
    def get_file_info(self, filepath: str) -> Dict:
        """Get basic file information"""
        print("[*] Getting file information...")
        
        info = {
            'name': os.path.basename(filepath),
            'size': os.path.getsize(filepath),
            'extension': Path(filepath).suffix,
        }
        
        # Use file command
        try:
            result = subprocess.run(
                ['file', filepath],
                capture_output=True, text=True, timeout=30
            )
            info['type'] = result.stdout.strip()
            print(f"[+] File type: {info['type']}")
        except:
            pass
        
        # Read magic bytes
        try:
            with open(filepath, 'rb') as f:
                info['magic_bytes'] = f.read(16).hex()
        except:
            pass
        
        self.results['file_info'] = info
        return info
    
    def extract_strings(self, filepath: str, min_length: int = 6) -> List[str]:
        """Extract strings from file"""
        print("[*] Extracting strings...")
        
        strings = []
        suspicious = []
        
        try:
            # Use strings command
            result = subprocess.run(
                ['strings', '-a', '-n', str(min_length), filepath],
                capture_output=True, text=True, timeout=60
            )
            
            all_strings = result.stdout.split('\n')
            
            # Categorize strings
            for s in all_strings:
                s = s.strip()
                if not s:
                    continue
                
                strings.append(s)
                
                # Search for flags
                self._search_flags(s)
                
                # Check for suspicious patterns
                s_lower = s.lower()
                
                # URLs
                if 'http://' in s_lower or 'https://' in s_lower:
                    suspicious.append(f"URL: {s}")
                    self.results['iocs'].append(s)
                
                # IP addresses
                if re.match(r'\d+\.\d+\.\d+\.\d+', s):
                    suspicious.append(f"IP: {s}")
                    self.results['iocs'].append(s)
                
                # Registry paths
                if 'hkey_' in s_lower or 'software\\' in s_lower:
                    suspicious.append(f"Registry: {s}")
                
                # File paths
                if 'c:\\' in s_lower or '/tmp/' in s_lower or '/etc/' in s_lower:
                    suspicious.append(f"Path: {s}")
                
                # Commands
                if any(cmd in s_lower for cmd in ['cmd.exe', 'powershell', '/bin/sh', 'bash']):
                    suspicious.append(f"Command: {s}")
                
                # Base64
                if re.match(r'^[A-Za-z0-9+/]{20,}={0,2}$', s):
                    suspicious.append(f"Base64: {s[:50]}...")
                    try:
                        import base64
                        decoded = base64.b64decode(s).decode('utf-8', errors='ignore')
                        if decoded.isprintable():
                            self._search_flags(decoded)
                    except:
                        pass
            
            self.results['strings'] = strings[:500]  # Limit
            self.results['suspicious_strings'] = suspicious
            
            print(f"[+] Found {len(strings)} strings ({len(suspicious)} suspicious)")
            
        except Exception as e:
            print(f"[!] String extraction error: {e}")
        
        return strings
    
    def detect_packer(self, filepath: str) -> Optional[str]:
        """Detect if file is packed"""
        print("[*] Checking for packers...")
        
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            
            for packer, signatures in self.packer_signatures.items():
                for sig in signatures:
                    if sig in data:
                        self.results['packed'] = True
                        self.results['packer_detected'] = packer
                        print(f"[!] Packer detected: {packer}")
                        return packer
            
            # Check for high entropy sections (sign of packing)
            # Simplified check - real implementation would analyze PE sections
            
            print("[+] No known packer detected")
            
        except Exception as e:
            print(f"[!] Packer detection error: {e}")
        
        return None
    
    def analyze_pe(self, filepath: str) -> Dict:
        """Analyze PE file structure"""
        print("[*] Analyzing PE structure...")
        
        pe_info = {}
        
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            
            # Check for PE signature
            if data[:2] != b'MZ':
                print("[*] Not a PE file")
                return pe_info
            
            # Get PE offset
            pe_offset = struct.unpack('<I', data[0x3C:0x40])[0]
            
            if data[pe_offset:pe_offset+4] != b'PE\x00\x00':
                print("[*] Invalid PE signature")
                return pe_info
            
            # Basic PE info
            machine = struct.unpack('<H', data[pe_offset+4:pe_offset+6])[0]
            pe_info['machine'] = 'x64' if machine == 0x8664 else 'x86' if machine == 0x14c else hex(machine)
            
            num_sections = struct.unpack('<H', data[pe_offset+6:pe_offset+8])[0]
            pe_info['num_sections'] = num_sections
            
            # Check for common section names
            section_offset = pe_offset + 0xF8  # Simplified offset
            sections = []
            
            for i in range(min(num_sections, 10)):
                section_start = section_offset + (i * 40)
                section_name = data[section_start:section_start+8].rstrip(b'\x00').decode('utf-8', errors='ignore')
                sections.append(section_name)
            
            self.results['sections'] = sections
            pe_info['sections'] = sections
            
            # Check for suspicious sections
            suspicious_sections = ['.vmp', '.themida', '.upx', '.aspack', '.packed']
            for sec in sections:
                if any(sus in sec.lower() for sus in suspicious_sections):
                    self.results['suspicious_strings'].append(f"Suspicious section: {sec}")
                    self.results['packed'] = True
            
            print(f"[+] PE Info: {pe_info['machine']}, {num_sections} sections")
            print(f"[+] Sections: {', '.join(sections)}")
            
        except Exception as e:
            print(f"[!] PE analysis error: {e}")
        
        return pe_info
    
    def analyze_elf(self, filepath: str) -> Dict:
        """Analyze ELF file structure"""
        print("[*] Analyzing ELF structure...")
        
        elf_info = {}
        
        try:
            with open(filepath, 'rb') as f:
                magic = f.read(4)
            
            if magic != b'\x7fELF':
                print("[*] Not an ELF file")
                return elf_info
            
            # Use readelf
            result = subprocess.run(
                ['readelf', '-h', filepath],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                elf_info['header'] = result.stdout
                self._search_flags(result.stdout)
            
            # Get sections
            result = subprocess.run(
                ['readelf', '-S', filepath],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                sections = re.findall(r'\[\s*\d+\]\s+(\S+)', result.stdout)
                self.results['sections'] = sections
                elf_info['sections'] = sections
                print(f"[+] Sections: {', '.join(sections[:10])}")
            
            # Get symbols
            result = subprocess.run(
                ['readelf', '-s', filepath],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                self._search_flags(result.stdout)
            
        except FileNotFoundError:
            print("[!] readelf not installed")
        except Exception as e:
            print(f"[!] ELF analysis error: {e}")
        
        return elf_info
    
    def check_suspicious_apis(self, filepath: str) -> List[str]:
        """Check for suspicious API calls"""
        print("[*] Checking for suspicious APIs...")
        
        found_apis = []
        
        try:
            result = subprocess.run(
                ['strings', '-a', filepath],
                capture_output=True, text=True, timeout=60
            )
            
            content = result.stdout
            
            for category, apis in self.suspicious_apis.items():
                for api in apis:
                    if api in content:
                        found_apis.append(f"{category}: {api}")
            
            self.results['suspicious_apis'] = found_apis
            
            if found_apis:
                print(f"[!] Found {len(found_apis)} suspicious API references")
                for api in found_apis[:10]:
                    print(f"    -> {api}")
            
        except Exception as e:
            print(f"[!] API check error: {e}")
        
        return found_apis
    
    def run_yara(self, filepath: str, rules_path: str = None) -> List[str]:
        """Run YARA rules against file"""
        print("[*] Running YARA scan...")
        
        matches = []
        
        # Default basic rules
        basic_rules = """
rule Contains_Flag {
    strings:
        $flag1 = /flag\\{[^}]+\\}/ nocase
        $flag2 = /ctf\\{[^}]+\\}/ nocase
        $flag3 = /picoCTF\\{[^}]+\\}/ nocase
    condition:
        any of them
}

rule Suspicious_Strings {
    strings:
        $s1 = "cmd.exe" nocase
        $s2 = "powershell" nocase
        $s3 = "/bin/sh"
        $s4 = "HKEY_" nocase
        $s5 = "CreateRemoteThread"
        $s6 = "VirtualAlloc"
    condition:
        2 of them
}

rule Packed_Executable {
    strings:
        $upx = "UPX!"
        $aspack = ".aspack"
        $themida = ".themida"
        $vmp = ".vmp"
    condition:
        any of them
}
"""
        
        try:
            import yara
            
            rules = yara.compile(source=basic_rules)
            yara_matches = rules.match(filepath)
            
            for match in yara_matches:
                matches.append(str(match))
                print(f"[+] YARA match: {match}")
            
            self.results['yara_matches'] = matches
            
        except ImportError:
            print("[!] YARA Python module not installed")
        except Exception as e:
            print(f"[!] YARA error: {e}")
        
        return matches
    
    def analyze(self, filepath: str) -> Dict:
        """Full malware analysis"""
        print(f"\n[*] Analyzing file: {filepath}")
        print("=" * 60)
        
        if not os.path.exists(filepath):
            print(f"[!] File not found: {filepath}")
            return self.results
        
        # Run all analyses
        self.get_file_info(filepath)
        self.calculate_hashes(filepath)
        self.extract_strings(filepath)
        self.detect_packer(filepath)
        
        # Check file type and analyze accordingly
        file_info = self.results['file_info']
        file_type = file_info.get('type', '').lower()
        
        if 'pe32' in file_type or 'executable' in file_type:
            self.analyze_pe(filepath)
            self.check_suspicious_apis(filepath)
        elif 'elf' in file_type:
            self.analyze_elf(filepath)
            self.check_suspicious_apis(filepath)
        
        # Try YARA
        self.run_yara(filepath)
        
        # Summary
        print("\n" + "=" * 60)
        print("[*] Malware Analysis Summary")
        print("=" * 60)
        
        if self.results['flags_found']:
            print(f"\n[FLAG] FLAGS FOUND: {len(self.results['flags_found'])}")
            for flag in self.results['flags_found']:
                print(f"  -> {flag}")
        
        if self.results['packed']:
            print(f"\n[!] FILE IS PACKED: {self.results['packer_detected'] or 'Unknown packer'}")
        
        if self.results['suspicious_apis']:
            print(f"\n[!] SUSPICIOUS APIs: {len(self.results['suspicious_apis'])}")
        
        if self.results['iocs']:
            print(f"\n[!] IOCs FOUND: {len(self.results['iocs'])}")
            for ioc in self.results['iocs'][:10]:
                print(f"  -> {ioc}")
        
        return self.results
    
    def get_summary(self) -> str:
        """Get formatted summary"""
        lines = ["Malware Analysis Results", "=" * 40]
        
        lines.append(f"File: {self.results['file_info'].get('name', 'Unknown')}")
        lines.append(f"Size: {self.results['file_info'].get('size', 0)} bytes")
        
        if self.results['hashes']:
            lines.append(f"MD5: {self.results['hashes'].get('md5', 'N/A')}")
            lines.append(f"SHA256: {self.results['hashes'].get('sha256', 'N/A')}")
        
        lines.append(f"Packed: {'Yes - ' + str(self.results['packer_detected']) if self.results['packed'] else 'No'}")
        lines.append(f"Suspicious APIs: {len(self.results['suspicious_apis'])}")
        lines.append(f"IOCs: {len(self.results['iocs'])}")
        lines.append(f"Flags found: {len(self.results['flags_found'])}")
        
        if self.results['flags_found']:
            lines.append("\nFlags:")
            for flag in self.results['flags_found']:
                lines.append(f"  {flag}")
        
        return '\n'.join(lines)
